#pragma once

#include <regex>

#include "base/lockable.hpp"
#include "common/utility.hpp"
#include "common/http_utility.hpp"

namespace beast_router {

/// Provides the sequential routing functionality.
/**
 * The common class which provides the basic routing features 
 * e.g. get(), put(), post() and delete_() handling.<br>
 *
 * By using RegExp it stores and maps the corresponding executors 
 * given by invoking the respective linked methods.
 *
 * ### Example
 * ```cpp
 * #include "beast_router.hpp"
 * ...
 * auto clb = [](const http_server_request &rq, http_server_context &ctx, const std::smatch &match) {
 *      http_string_response rp{boost::beast::http::status::ok, rq.version()};
 *      rp.set(boost::beast::http::field::content_type, "text/html");
 *
 *      std::stringstream i_str;
 *      i_str << 
 *          "Generated by the thread: " << std::this_thread::get_id();
 *
 *      rp.body() = i_str.str();
 *
 *      rp.prepare_payload();
 *      rp.keep_alive(rq.keep_alive());
 *      ctx.send(rp);
 * }
 *
 * g_router.get(R"(^/.*$)", std::move(clb));
 * ```
 */
template<class Session>
class router
{
public:
    /// The self type
    using self_type = router<Session>;

    /// The session type
    using session_type = Session;

    /// The mutex type
    using mutex_type = typename base::lockable::mutex_type;

    /// The container type associated with the callbacks linked to the resource
    using resource_map_type = typename session_type::resource_map_type;

    /// The mothod type
    using method_type = typename session_type::method_type;

    /// The container type associated with the resource map
    using method_map_type = typename session_type::method_map_type;

    /// The storage type holds a callback
    using storage_type = typename session_type::storage_type;

    /// The pointer type for the method_map_type
    using method_map_pointer = std::shared_ptr<method_map_type>;

    /// The const pointer fpr the method_map_type
    using method_const_map_pointer = std::shared_ptr<const method_map_type>;

    /// Constructor
    router();

    /// Returns a reference to the `mutex_type`
    /**
     * This function is used to get the mutex for further usage and controlling the critical sections
     * along with this routing functionality
     *
     * @returns mutex_type
     */
    mutex_type &
    get_mutex() const;

    /// The method adds handlers and links them within the given path (RegExp) for the `"GET"` method
    /**
     * The method associates a list of handlers and binds to the path for cases, when the respective<br>
     * HTTP method is equal to `"GET"`.
     * The method is instantiated under the following conditions:
     * - `template<class ...OnRequest>` carries the list of executables routines
     * - the methods comply and respect the signature and may be passed as a parameter for the `sorage` creation
     *
     * ```cpp
     * std::is_invocable_v<OnRequest, const request_type &, context_type &, const std::smatch &>
     * ```
     * 
     * @param path The <tt>std::string</tt> type and refers to 
     * RegExp associated within the handlers
     *
     * @param on_request A variadic template of the handlers to be 
     * sequentially executed for the given <tt>path</tt>
     *
     * @returns void
     *
     * @note A handler must return either void or bool
     * - in case when the return type is void then the next handler executes right after the current is finished
     * - in case when the return type is the boolean data type and then the execution is based on the following vlaues:
     *   - if return type is equal to `true` then the next handler executes
     *   - if return type is equal to `false` then the complete chain of handlers breaks
     * 
     * @note Two cases of handlers declaration:
     * - std::function<bool(const request_type &, context_type &, const std::smatch &)>
     * - std::function<void(const request_type &, context_type &, const std::smatch &)>
     * 
     * @note The callback has to be compatible with the signatures which accept the following set of parameters:
     * - const request_type &, context_type &, const std::smatch &
     * - const request_type &, context_type &
     * - context_type &
     */
    template<
        class ...OnRequest,
        std::enable_if_t<
            utility::is_class_creatable_v<storage_type, OnRequest...>, bool
        > = true>
    void
    get(const std::string &path, OnRequest &&...on_request)
    {
        add_resource(path, method_type::get, storage_type{std::forward<OnRequest>(on_request)...});
    }

    /// The methods adds handlers and links them within the given path (RegExp) for the `"PUT"` method
    /**
     * @param path The <tt>std::string</tt> type and refers to RegExp associated within the handlers
     * @param on_request A variadic template of the handlers to be sequentially executed for the given <tt>path</tt>
     * @returns void
     * @note For more in details please refere to the @ref get() method description
     */
    template<
        class ...OnRequest,
        std::enable_if_t<
            utility::is_class_creatable_v<storage_type, OnRequest...>, bool
        > = true>
    void
    put(const std::string &path, OnRequest &&...on_request)
    {
        add_resource(path, method_type::put, storage_type{std::forward<OnRequest>(on_request)...});
    }
    
    /// The methods adds handlers and links them within the given path (RegExp) for the `"POST"` method
    /**
     * @param path The <tt>std::string</tt> type and refers to RegExp associated within the handlers
     * @param on_request A variadic template of the handlers to be sequentially executed for the given <tt>path</tt>
     * @returns void
     * @note For more in details please refere to the @ref get() method description
     */
    template<
        class ...OnRequest,
        std::enable_if_t<
            utility::is_class_creatable_v<storage_type, OnRequest...>, bool
        > = true>
    void
    post(const std::string &path, OnRequest &&...on_request)
    {
        add_resource(path, method_type::post, storage_type{std::forward<OnRequest>(on_request)...});
    }
    
    /// The methods adds handlers and links them within the given path (RegExp) for the `"DELETE"` method
    /**
     * @param path The <tt>std::string</tt> type and refers to RegExp associated within the handlers
     * @param on_request A variadic template of the handlers to be sequentially executed for the given <tt>path</tt>
     * @returns void
     * @note For more in details please refere to the @ref get() method description
     */
    template<
        class ...OnRequest,
        std::enable_if_t<
            utility::is_class_creatable_v<storage_type, OnRequest...>, bool
        > = true>
    void
    delete_(const std::string &path, OnRequest &&...on_request)
    {
        add_resource(path, method_type::delete_, storage_type{std::forward<OnRequest>(on_request)...});
    }

    /// The actions executors when no handlers for the resource are found
    /**
     * @param on_actio the list of actions to be seq. invoked
     * @returns void
     *
     * @note The same set of rules are applied as for other method, @ref get()
     */
    template<
        class ...OnAction,
        std::enable_if_t<
            utility::is_class_creatable_v<storage_type, OnAction...>, bool
        > = true>
    void
    not_found(OnAction &&...on_action)
    {
        add_resource("", method_type::unknown, storage_type{std::forward<OnAction>(on_action)...});
    }

    /// Obtains a const reference to the resource map
    /**
     * @returns method_const_map_pointer
     */
    method_const_map_pointer 
    get_resource_map() const;

private:
    void
    add_resource(const std::string &path, const method_type &method, storage_type &&storage);

    static bool not_found_handler(const typename session_type::request_type &rq, 
        typename session_type::context_type &ctx)
    {
        ctx.send(make_string_response(http::status::not_found, 
            rq.version(), "Not Found"));
        return false; // break the chain of calls
    }

    mutable mutex_type m_mutex;
    method_map_pointer m_method_map;
};

} // namespace beast_router

#include "impl/router.ipp"
