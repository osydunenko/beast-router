#pragma once

#include <regex>

#include "base/lockable.hpp"

namespace beast_router {

/// Provides the sequential routing functionality.
/**
 * The common class which provides the basic routing features 
 * e.g. get(), put(), post() and delete_() handling.<br>
 * By using RegExp it stores and maps the corresponding executors 
 * given by invoking the respective linked methods.
 *
 * ### Example
 * ```cpp
 * #include "beast_router.hpp"
 * ...
 * auto clb = [](const beast_http_request &rq, http_context &ctx, const std::smatch &match) {
 *      beast_string_response rp{boost::beast::http::status::ok, rq.version()};
 *      rp.set(boost::beast::http::field::content_type, "text/html");
 *
 *      std::stringstream i_str;
 *      i_str << 
 *          "Generated by the thread: " << std::this_thread::get_id();
 *
 *      rp.body() = i_str.str();
 *
 *      rp.prepare_payload();
 *      rp.keep_alive(rq.keep_alive());
 *      ctx.send(rp);
 * }
 *
 * g_router.get(R"(^/.*$)", std::move(clb));
 * ```
 */
template<class Session>
class router
{
public:
    /// The self type
    using self_type = router<Session>;

    /// The session type
    using session_type = Session;

    /// The mutex type
    using mutex_type = typename base::lockable::mutex_type;

    /// The container type associated with the callbacks linked to the resource
    using resource_map_type = typename session_type::resource_map_type;

    /// The mothod type
    using method_type = typename session_type::method_type;

    /// The container type associated with the resource map
    using method_map_type = typename session_type::method_map_type;

    /// The storage type holds a callback
    using storage_type = typename session_type::storage_type;

    /// The pointer type for the method_map_type
    using method_map_pointer = std::shared_ptr<method_map_type>;

    /// The const pointer fpr the method_map_type
    using method_const_map_pointer = std::shared_ptr<const method_map_type>;

    router();

    /// Returns a reference to the `mutex_type`
    /**
     * This function is used to get the mutex for further usage and controlling the critical sections
     * along with this routing functionality
     *
     * @returns mutex_type
     */
    mutex_type &get_mutex() const;

    /// The method adds handlers and links them within the given path (RegExp) for the `"GET"` method
    /**
     * The method associates a list of handlers and binds to the path for cases, when the respective<br>
     * HTTP method is equal to `"GET"`.
     * The method is instantiated under the following conditions:
     * - `template<class ...OnRequest>` carries the list of executables routines
     * - the methods comply and respect the signature and may be passed as a parameter for the `sorage` creation
     *
     * ```cpp
     * std::is_invocable_v<OnRequest, const request_type &, context_type &, const std::smatch &>
     * ```
     * 
     * @param path The <tt>std::string</tt> type and refers to RegExp associated within the handlers
     * @param on_request A variadic template of the handlers to be sequentially executed for the given <tt>path</tt>
     * @returns void
     *
     * @note A handler must return either void or bool
     * - in case when the return type is void then the next handler executes right after the current is finished
     * - in case when the return type is the boolean data type and then the execution is based on the following vlaues:
     *   - if return type is equal to `true` then the next handler executes
     *   - if return type is equal to `false` then the complete chain of handlers breaks
     * @note Two cases of handlers declaration:
     * - std::function<bool(const request_type &, context_type &, const std::smatch &)>
     * - std::function<void(const request_type &, context_type &, const std::smatch &)>
     * @note The callback has to be compatible with the signatures which accept the following set of parameters:
     * - const request_type &, context_type &, const std::smatch &
     * - const request_type &, context_type &
     * - context_type &
     */
    template<class ...OnRequest>
    auto get(const std::string &path, OnRequest &&...on_request)
        -> decltype(storage_type(std::declval<OnRequest>()...), void());

    /// The methods adds handlers and links them within the given path (RegExp) for the `"PUT"` method
    /**
     * @param path The <tt>std::string</tt> type and refers to RegExp associated within the handlers
     * @param on_request A variadic template of the handlers to be sequentially executed for the given <tt>path</tt>
     * @returns void
     * @note For more in details please refere to the get() method description
     */
    template<class ...OnRequest>
    auto put(const std::string &path, OnRequest &&...on_request)
        -> decltype(storage_type(std::declval<OnRequest>()...), void());
    
    /// The methods adds handlers and links them within the given path (RegExp) for the `"POST"` method
    /**
     * @param path The <tt>std::string</tt> type and refers to RegExp associated within the handlers
     * @param on_request A variadic template of the handlers to be sequentially executed for the given <tt>path</tt>
     * @returns void
     * @note For more in details please refere to the get() method description
     */
    template<class ...OnRequest>
    auto post(const std::string &path, OnRequest &&...on_request)
        -> decltype(storage_type(std::declval<OnRequest>()...), void());
    
    /// The methods adds handlers and links them within the given path (RegExp) for the `"DELETE"` method
    /**
     * @param path The <tt>std::string</tt> type and refers to RegExp associated within the handlers
     * @param on_request A variadic template of the handlers to be sequentially executed for the given <tt>path</tt>
     * @returns void
     * @note For more in details please refere to the get() method description
     */
    template<class ...OnRequest>
    auto delete_(const std::string &path, OnRequest &&...on_request)
        -> decltype(storage_type(std::declval<OnRequest>()...), void());

    method_const_map_pointer get_resource_map() const;

private:
    void add_resource(const std::string &path, const method_type &method, storage_type &&storage);

    mutable mutex_type m_mutex;
    method_map_pointer m_method_map;
};

} // namespace beast_router

#include "impl/router.ipp"
